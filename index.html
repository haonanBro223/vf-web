<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>VexFlow Sheet</title>
  <!-- 1. 引入 UMD 构建 -->
  <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.3/releases/vexflow-min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
    }
     /* 输出容器允许溢出，并给左侧留出 20px 空间 */
    #output {
       overflow: visible;
       padding-left: 20px;
    }
     /* SVG 本身允许溢出 */
    svg {
       overflow: visible;
    }
  </style>
  <script>
    // If embed=1, strip out all body content except output
    const params = new URLSearchParams(window.location.search);
    if (params.get('embed') === '1') {
      document.addEventListener('DOMContentLoaded', () => {
                const output = document.getElementById('output');
        document.body.innerHTML = '';
        document.body.appendChild(output);
      });
    }
  </script>
</head>
<body>
  <div id="output"></div>
  <script>
  const VF = Vex.Flow;
  const div = document.getElementById("output");
  const renderer = new VF.Renderer(div, VF.Renderer.Backends.SVG);
  renderer.resize(700, 300);
  const context = renderer.getContext();

  // 1. 只绘制空谱表和竖线、花括号
  function drawStaves() {
    // 高音谱号
    const treble = new VF.Stave(40, 40, 300)
      .addClef("treble")
      .setContext(context)
      .setEndBarType(VF.Barline.type.NONE)
      .draw();

    // 低音谱号
    const bass = new VF.Stave(40, 140, 300)
      .addClef("bass")
      .setContext(context)
      .setEndBarType(VF.Barline.type.NONE)
      .draw();

    // 手动画贯穿竖线
    const x = treble.getX();
    const yTop = treble.getYForLine(0);
    const yBot = bass.getYForLine(4);
    context.beginPath();
    context.moveTo(x, yTop);
    context.lineTo(x, yBot);
    context.setLineWidth(2);
    context.stroke();

    // 画花括号
    new VF.StaveConnector(treble, bass)
      .setType(VF.StaveConnector.type.BRACE)
      .setContext(context)
      .draw();
  }

  // 2. 在空谱表基础上按需绘制单个音符
  function renderNote(note) {
    drawStaves();
    if (!note) return;
    const parts = note.toLowerCase().match(/^([a-g])(#?)(\d)$/);
    if (!parts) throw new Error("Invalid note: " + note);
    const [_, letter, sharp, octave] = parts;
    const key = `${letter}/${octave}`;
    const useTreble = parseInt(octave, 10) >= 4;

    const staveRef = useTreble
      ? new VF.Stave(40, 40, 300)
      : new VF.Stave(40, 140, 300); // We only need a reference for voice.draw

    const noteObj = new VF.StaveNote({
      clef: useTreble ? "treble" : "bass",
      keys: [key],
      duration: "q",
    });
    if (sharp) noteObj.addAccidental(0, new VF.Accidental("#"));

    const voice = new VF.Voice({ num_beats: 1, beat_value: 4 }).addTickables([noteObj]);
    new VF.Formatter().joinVoices([voice]).format([voice], 300);
    voice.draw(context, useTreble ? treble : bass);
  }

  // 3. 初次根据 URL 渲染
  renderNote(new URLSearchParams(window.location.search).get("note"));

  // 4. 监听小程序 postMessage，动态更新
  window.addEventListener("message", (evt) => {
    if (evt.data && evt.data.note) {
      renderNote(evt.data.note);
    }
  });
  </script>
</body>
</html>
